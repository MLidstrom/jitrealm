using JitRealm.Mud.Configuration;
using Npgsql;

namespace JitRealm.Mud.AI;

internal static class PostgresMemorySchema
{
    public static async Task<bool> EnsureAsync(NpgsqlDataSource dataSource, MemorySettings settings, CancellationToken cancellationToken)
    {
        await using var conn = await dataSource.OpenConnectionAsync(cancellationToken);

        // pgvector extension may require elevated privileges; treat failure as non-fatal if UsePgvector is false.
        var usePgvector = settings.UsePgvector;
        if (usePgvector)
        {
            try
            {
                await using var cmd = new NpgsqlCommand("CREATE EXTENSION IF NOT EXISTS vector;", conn);
                await cmd.ExecuteNonQueryAsync(cancellationToken);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Memory] WARNING: Failed to create/verify pgvector extension: {ex.Message}");
                Console.WriteLine("[Memory] Continuing without vector support (set Memory.UsePgvector=false to silence).");
                usePgvector = false;
            }
        }

        // Goals (stackable with importance-based priority)
        // Create table first (without indexes that depend on new columns)
        await ExecAsync(conn, @"
CREATE TABLE IF NOT EXISTS npc_goals (
  npc_id        text NOT NULL,
  goal_type     text NOT NULL,
  target_player text NULL,
  params        jsonb NOT NULL DEFAULT '{}'::jsonb,
  status        text NOT NULL DEFAULT 'active',
  importance    int NOT NULL DEFAULT 50,
  updated_at    timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (npc_id, goal_type)
);
", cancellationToken);

        // Migration: Add importance column if table already exists without it
        // Must run BEFORE creating indexes on importance
        await ExecMigrationAsync(conn, @"
ALTER TABLE npc_goals ADD COLUMN IF NOT EXISTS importance int NOT NULL DEFAULT 50;
", cancellationToken);

        // Migration: Add goal_type column if table has old schema
        await ExecMigrationAsync(conn, @"
ALTER TABLE npc_goals ADD COLUMN IF NOT EXISTS goal_type text NOT NULL DEFAULT 'default';
", cancellationToken);

        // Migration: Change primary key if old schema (npc_id only)
        // This is a best-effort migration - may fail if duplicates exist
        await ExecMigrationAsync(conn, @"
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'npc_goals_pkey'
    AND conrelid = 'npc_goals'::regclass
  ) THEN
    -- Check if it's the old single-column key
    IF (SELECT array_length(conkey, 1) FROM pg_constraint
        WHERE conname = 'npc_goals_pkey' AND conrelid = 'npc_goals'::regclass) = 1 THEN
      ALTER TABLE npc_goals DROP CONSTRAINT npc_goals_pkey;
      ALTER TABLE npc_goals ADD PRIMARY KEY (npc_id, goal_type);
    END IF;
  END IF;
END$$;
", cancellationToken);

        // Now create indexes (after migrations ensure columns exist)
        await ExecAsync(conn, @"
CREATE INDEX IF NOT EXISTS idx_npc_goals_target_player ON npc_goals (target_player);
CREATE INDEX IF NOT EXISTS idx_npc_goals_npc_importance ON npc_goals (npc_id, importance ASC);
", cancellationToken);

        // Needs (drives): survive, hunger, rest, etc.
        await ExecAsync(conn, @"
CREATE TABLE IF NOT EXISTS npc_needs (
  npc_id     text NOT NULL,
  need_type  text NOT NULL,
  level      int  NOT NULL DEFAULT 1,
  params     jsonb NOT NULL DEFAULT '{}'::jsonb,
  status     text NOT NULL DEFAULT 'active',
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (npc_id, need_type)
);
CREATE INDEX IF NOT EXISTS idx_npc_needs_npc_level ON npc_needs (npc_id, level ASC);
", cancellationToken);

        // Migration: move any legacy "survive" goals into npc_needs(level=1), then delete from npc_goals.
        // This makes "survive" disappear completely from npc_goals going forward.
        await ExecMigrationAsync(conn, @"
INSERT INTO npc_needs (npc_id, need_type, level, params, status, updated_at)
SELECT npc_id,
       'survive' as need_type,
       1 as level,
       params,
       status,
       now()
FROM npc_goals
WHERE goal_type = 'survive'
ON CONFLICT (npc_id, need_type) DO NOTHING;

DELETE FROM npc_goals WHERE goal_type = 'survive';
", cancellationToken);

        // Memories
        // Note: id generated by app (GUID) to avoid requiring pgcrypto/uuid-ossp.
        await ExecAsync(conn, @"
CREATE TABLE IF NOT EXISTS npc_memories (
  id             uuid PRIMARY KEY,
  npc_id         text NOT NULL,
  subject_player text NULL,
  room_id        text NULL,
  area_id        text NULL,
  kind           text NOT NULL,
  importance     int  NOT NULL DEFAULT 50 CHECK (importance BETWEEN 0 AND 100),
  tags           text[] NOT NULL DEFAULT ARRAY[]::text[],
  content        text NOT NULL,
  created_at     timestamptz NOT NULL DEFAULT now(),
  expires_at     timestamptz NULL
);
", cancellationToken);

        if (usePgvector)
        {
            await ExecAsync(conn,
                $"ALTER TABLE npc_memories ADD COLUMN IF NOT EXISTS embedding vector({settings.EmbeddingDimensions}) NULL;",
                cancellationToken);
        }

        await ExecAsync(conn, @"
CREATE INDEX IF NOT EXISTS idx_npc_memories_npc_created ON npc_memories (npc_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_npc_memories_npc_subject_created ON npc_memories (npc_id, subject_player, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_npc_memories_expires ON npc_memories (npc_id, expires_at);
CREATE INDEX IF NOT EXISTS idx_npc_memories_tags_gin ON npc_memories USING GIN (tags);
", cancellationToken);

        // Shared world KB
        await ExecAsync(conn, @"
CREATE TABLE IF NOT EXISTS world_kb (
  key         text PRIMARY KEY,
  value       jsonb NOT NULL,
  tags        text[] NOT NULL DEFAULT ARRAY[]::text[],
  visibility  text NOT NULL DEFAULT 'public',
  updated_at  timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_world_kb_tags_gin ON world_kb USING GIN (tags);
", cancellationToken);

        return usePgvector;
    }

    private static async Task ExecAsync(NpgsqlConnection conn, string sql, CancellationToken cancellationToken)
    {
        await using var cmd = new NpgsqlCommand(sql, conn);
        await cmd.ExecuteNonQueryAsync(cancellationToken);
    }

    /// <summary>
    /// Execute migration SQL, silently ignoring errors (best-effort).
    /// </summary>
    private static async Task ExecMigrationAsync(NpgsqlConnection conn, string sql, CancellationToken cancellationToken)
    {
        try
        {
            await using var cmd = new NpgsqlCommand(sql, conn);
            await cmd.ExecuteNonQueryAsync(cancellationToken);
        }
        catch
        {
            // Migration errors are expected for fresh databases or already-migrated databases
        }
    }
}


